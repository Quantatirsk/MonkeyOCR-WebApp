/**
 * BlockMarkdownViewer Component
 * Enhanced Markdown renderer with block marking and sync capabilities
 */

import React, { useMemo, useRef, useEffect } from 'react';
import ReactMarkdown from 'react-markdown';
import rehypeRaw from 'rehype-raw';
import rehypeSanitize from 'rehype-sanitize';
import { BlockData, BlockSelection } from '../../types';
import { ContentMatcher, BlockProcessor } from '../../utils/blockProcessor';
import { BlockMarkdownGenerator } from '../../utils/blockMarkdownGenerator';
import './block-styles.css';

export interface BlockMarkdownViewerProps {
  /** Markdown content to render */
  content: string;
  /** Block data for mapping */
  blockData?: BlockData[];
  /** Currently selected block */
  selectedBlock?: BlockSelection;
  /** Highlighted blocks */
  highlightedBlocks?: number[];
  /** Whether sync is enabled */
  syncEnabled?: boolean;
  /** Callback for block click */
  onBlockClick?: (blockIndex: number) => void;
  /** Callback for block hover */
  onBlockHover?: (blockIndex: number | null) => void;
  /** Font size multiplier */
  fontSize?: number;
  /** CSS class name */
  className?: string;
}

interface BlockMapping {
  blockIndex: number;
  paragraphIndex: number;
  blockType: 'text' | 'title' | 'image';
}

export const BlockMarkdownViewer: React.FC<BlockMarkdownViewerProps> = ({
  content,
  blockData = [],
  selectedBlock = { blockIndex: null, pageNumber: null, isActive: false },
  highlightedBlocks = [],
  syncEnabled = false,
  onBlockClick,
  onBlockHover,
  fontSize = 100,
  className = ''
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const [hoveredBlock, setHoveredBlock] = React.useState<number | null>(null);

  // Create block-to-paragraph mapping - now 1:1 since content is generated from blocks
  const blockMappings = useMemo<BlockMapping[]>(() => {
    if (!syncEnabled || blockData.length === 0) return [];

    // Check if this content was generated by BlockMarkdownGenerator
    // If so, use direct 1:1 mapping, otherwise fall back to content matching
    const isGeneratedContent = content.includes('---') || content.length < 50000; // Heuristic
    
    if (isGeneratedContent) {
      // Use direct mapping from BlockMarkdownGenerator
      const directMapping = BlockMarkdownGenerator.createBlockMapping(blockData);
      const mappings: BlockMapping[] = [];
      
      directMapping.forEach((paragraphIndex, blockIndex) => {
        const block = BlockProcessor.findBlockByIndex(blockData, blockIndex);
        if (block) {
          mappings.push({
            blockIndex,
            paragraphIndex,
            blockType: block.type
          });
        }
      });
      
      console.log('🎯 Using direct block mapping:', mappings.length, 'mappings');
      return mappings.sort((a, b) => a.paragraphIndex - b.paragraphIndex);
    } else {
      // Fall back to content matching for original markdown
      const blockToMarkdownMap = ContentMatcher.matchBlocksToMarkdown(blockData, content);
      const mappings: BlockMapping[] = [];

      blockToMarkdownMap.forEach((paragraphIndex, blockIndex) => {
        const block = BlockProcessor.findBlockByIndex(blockData, blockIndex);
        if (block) {
          mappings.push({
            blockIndex,
            paragraphIndex,
            blockType: block.type
          });
        }
      });
      
      console.log('🔍 Using content matching:', mappings.length, 'mappings');
      return mappings.sort((a, b) => a.paragraphIndex - b.paragraphIndex);
    }
  }, [blockData, content, syncEnabled]);

  // Just return clean content for proper Markdown rendering
  const processedContent = useMemo(() => {
    return content;
  }, [content]);

  // Map rendered elements to block indices after render
  const markElementsWithBlockData = React.useCallback(() => {
    if (!syncEnabled || !containerRef.current || blockMappings.length === 0) return;

    const container = containerRef.current;
    const paragraphs = container.querySelectorAll('.markdown-paragraph, .markdown-heading');
    
    // Clear existing data attributes
    paragraphs.forEach(el => {
      el.removeAttribute('data-block-index');
      el.removeAttribute('data-block-type');
    });

    // Map paragraphs to blocks based on their order
    let renderedParagraphIndex = 0;
    let skippedSeparators = 0;
    
    paragraphs.forEach((paragraph) => {
      // Skip if this is a page separator or empty
      const textContent = paragraph.textContent?.trim();
      if (!textContent || textContent === '---') {
        skippedSeparators++;
        console.log(`⏭️  Skipping page separator ${skippedSeparators} (not counted in mapping)`);
        return;
      }

      const mapping = blockMappings.find(m => m.paragraphIndex === renderedParagraphIndex);
      if (mapping) {
        paragraph.setAttribute('data-block-index', mapping.blockIndex.toString());
        paragraph.setAttribute('data-block-type', mapping.blockType);
        
        console.log(`✅ Mapped paragraph ${renderedParagraphIndex} → block ${mapping.blockIndex} (${mapping.blockType})`);
        
        // Add CSS classes for styling
        const isSelected = selectedBlock.blockIndex === mapping.blockIndex && selectedBlock.isActive;
        const isHighlighted = highlightedBlocks.includes(mapping.blockIndex);
        const isHovered = hoveredBlock === mapping.blockIndex;

        paragraph.classList.remove('block-selected', 'block-highlighted', 'block-hovered');
        paragraph.classList.add('block-paragraph', `block-type-${mapping.blockType}`);
        
        if (isSelected) paragraph.classList.add('block-selected');
        if (isHighlighted) paragraph.classList.add('block-highlighted');  
        if (isHovered) paragraph.classList.add('block-hovered');
      } else {
        console.warn(`❌ No mapping found for paragraph ${renderedParagraphIndex}`);
      }
      
      renderedParagraphIndex++;
    });
  }, [syncEnabled, blockMappings, selectedBlock, highlightedBlocks, hoveredBlock]);

  // Handle block interactions
  const handleBlockClick = React.useCallback((event: MouseEvent) => {
    const target = event.target as HTMLElement;
    const blockElement = target.closest('[data-block-index]');
    
    if (blockElement && onBlockClick) {
      const blockIndex = parseInt(blockElement.getAttribute('data-block-index') || '-1', 10);
      if (blockIndex >= 0) {
        onBlockClick(blockIndex);
      }
    }
  }, [onBlockClick]);

  const handleBlockHover = React.useCallback((event: MouseEvent) => {
    const target = event.target as HTMLElement;
    const blockElement = target.closest('[data-block-index]');
    
    if (blockElement) {
      const blockIndex = parseInt(blockElement.getAttribute('data-block-index') || '-1', 10);
      if (blockIndex >= 0 && blockIndex !== hoveredBlock) {
        setHoveredBlock(blockIndex);
        if (onBlockHover) {
          onBlockHover(blockIndex);
        }
      }
    } else if (hoveredBlock !== null) {
      setHoveredBlock(null);
      if (onBlockHover) {
        onBlockHover(null);
      }
    }
  }, [hoveredBlock, onBlockHover]);

  const handleMouseLeave = React.useCallback(() => {
    if (hoveredBlock !== null) {
      setHoveredBlock(null);
      if (onBlockHover) {
        onBlockHover(null);
      }
    }
  }, [hoveredBlock, onBlockHover]);

  // Attach event listeners
  useEffect(() => {
    const container = containerRef.current;
    if (!container || !syncEnabled) return;

    container.addEventListener('click', handleBlockClick);
    container.addEventListener('mouseover', handleBlockHover);
    container.addEventListener('mouseleave', handleMouseLeave);

    return () => {
      container.removeEventListener('click', handleBlockClick);
      container.removeEventListener('mouseover', handleBlockHover);
      container.removeEventListener('mouseleave', handleMouseLeave);
    };
  }, [handleBlockClick, handleBlockHover, handleMouseLeave, syncEnabled]);

  // Effect to mark elements after render
  useEffect(() => {
    markElementsWithBlockData();
  }, [markElementsWithBlockData]);

  // Scroll to selected block
  useEffect(() => {
    if (!syncEnabled || !selectedBlock.isActive || selectedBlock.blockIndex === null) return;

    const container = containerRef.current;
    if (!container) return;

    const targetElement = container.querySelector(`[data-block-index="${selectedBlock.blockIndex}"]`);
    if (targetElement) {
      targetElement.scrollIntoView({
        behavior: 'smooth',
        block: 'center'
      });
    }
  }, [selectedBlock, syncEnabled]);

  // Markdown components with custom renderers
  const components = useMemo(() => ({
    // Custom paragraph renderer
    p: ({ children, ...props }: any) => (
      <p {...props} className="markdown-paragraph">
        {children}
      </p>
    ),
    
    // Custom heading renderers
    h1: ({ children, ...props }: any) => (
      <h1 {...props} className="markdown-heading markdown-h1">
        {children}
      </h1>
    ),
    h2: ({ children, ...props }: any) => (
      <h2 {...props} className="markdown-heading markdown-h2">
        {children}
      </h2>
    ),
    h3: ({ children, ...props }: any) => (
      <h3 {...props} className="markdown-heading markdown-h3">
        {children}
      </h3>
    ),
    h4: ({ children, ...props }: any) => (
      <h4 {...props} className="markdown-heading markdown-h4">
        {children}
      </h4>
    ),
    h5: ({ children, ...props }: any) => (
      <h5 {...props} className="markdown-heading markdown-h5">
        {children}
      </h5>
    ),
    h6: ({ children, ...props }: any) => (
      <h6 {...props} className="markdown-heading markdown-h6">
        {children}
      </h6>
    ),

    // Custom image renderer
    img: ({ src, alt, ...props }: any) => (
      <div className="markdown-image-container">
        <img 
          {...props} 
          src={src} 
          alt={alt}
          className="markdown-image"
          loading="lazy"
        />
        {alt && <figcaption className="markdown-image-caption">{alt}</figcaption>}
      </div>
    ),

    // Custom code block renderer
    pre: ({ children, ...props }: any) => (
      <pre {...props} className="markdown-code-block">
        {children}
      </pre>
    ),

    // Custom inline code renderer
    code: ({ children, ...props }: any) => (
      <code {...props} className="markdown-inline-code">
        {children}
      </code>
    ),

    // Custom blockquote renderer
    blockquote: ({ children, ...props }: any) => (
      <blockquote {...props} className="markdown-blockquote">
        {children}
      </blockquote>
    ),

    // Custom list renderers
    ul: ({ children, ...props }: any) => (
      <ul {...props} className="markdown-list markdown-unordered-list">
        {children}
      </ul>
    ),
    ol: ({ children, ...props }: any) => (
      <ol {...props} className="markdown-list markdown-ordered-list">
        {children}
      </ol>
    ),
    li: ({ children, ...props }: any) => (
      <li {...props} className="markdown-list-item">
        {children}
      </li>
    ),

    // Custom table renderers
    table: ({ children, ...props }: any) => (
      <div className="markdown-table-container">
        <table {...props} className="markdown-table">
          {children}
        </table>
      </div>
    ),
    thead: ({ children, ...props }: any) => (
      <thead {...props} className="markdown-table-header">
        {children}
      </thead>
    ),
    tbody: ({ children, ...props }: any) => (
      <tbody {...props} className="markdown-table-body">
        {children}
      </tbody>
    ),
    tr: ({ children, ...props }: any) => (
      <tr {...props} className="markdown-table-row">
        {children}
      </tr>
    ),
    th: ({ children, ...props }: any) => (
      <th {...props} className="markdown-table-header-cell">
        {children}
      </th>
    ),
    td: ({ children, ...props }: any) => (
      <td {...props} className="markdown-table-cell">
        {children}
      </td>
    )
  }), []);

  return (
    <div 
      ref={containerRef}
      className={`block-markdown-viewer ${syncEnabled ? 'sync-enabled' : ''} ${className}`}
      style={{ fontSize: `${fontSize}%` }}
    >
      {/* Block mapping debug info (only in development) */}
      {process.env.NODE_ENV === 'development' && syncEnabled && blockMappings.length > 0 && (
        <div className="block-debug-info">
          <details>
            <summary>Block Mappings ({blockMappings.length})</summary>
            <pre>{JSON.stringify(blockMappings, null, 2)}</pre>
          </details>
        </div>
      )}

      {/* Markdown content */}
      <ReactMarkdown
        components={components}
        rehypePlugins={[rehypeRaw, rehypeSanitize]}
        className="markdown-content"
      >
        {processedContent}
      </ReactMarkdown>

    </div>
  );
};

export default BlockMarkdownViewer;